---
isDraft: true
metaContent:
    {
        title: "Making an interactive playground led me into making a DSL",
        description: "Why making a playgroung for generating fractals using L-systems led me into creating a DSL?",
        heroImage: [true, /index/pub/journey-from-medium-to-my-website.png],
        keywords: ["coding", "fractals", "geometry", "generative functions", "DSL", "interpreter"],
    }
createdAt: "14 Jul 2025"

---
import cdnify from "@/lib/cdnify"

## The first line segment

If you have browsed my website them you might be aware of my project [Geometric Visualiser](/project/geo-vis), if not then check it out. I made it after getting fascinated by the simplistic beauty of fractals, never thinking they'll lead me here.

In this article, we'll be discussing about the fractals that are made purely with line segments which are generated by defining a set of recursive rules/grammar called Lindenmayer system or L-system. Below is an example.

We start with state, `I` position at origin facing in the positive X direction and follow the rules and update the state:

- `I` => `F`, stay where you are
- `F` => `FPH`, move one step in the direction you are facing
- `H` => `FNH`, move one step in the direction you are facing
- `P` => `P`, turn left
- `N` => `N`, turn right

> Follow the rules to generate new state and at the end of update process, do the task.
>
> All the line segments drawn should be of same length, unless stated oterwise.

Now, after doing this process 4 times we can see the following:

1. `I`
2. `F`
3. `FPH`
4. `FPHPFNH`
5. `FPHPFNHPFPHNFNH`

This resulting drawing from the above process will look like this:

<div image-wrapper><img src={cdnify([false,"/index/pub/dragon-3.png"])} /></div>

This is called the dragon curve.

The above set of rules is easy to store as a type like this.

```typescript showLineNumbers=true title="types-for-hardcoded-system.ts"
// A two dimensional vector
type V2 = [number,number];

// A function which takes in
// your current position,
// and the direction you are facing towards
// as arguments and returns your new position
// and direction
type Transformer = (V2, V2) => [V2, V2];

// An instruction can either be terminal or non terminal
// i.e. do we need to expand it or not.
// If it is non terminal where the first value of this tuple is false,
// then the third value of the tuple is what it'll expand into.
type Instruction = [false, Transformer, string] | [true, Transformer];

type Rules = {
    I: Instruction;
    [key: string]: Instruction
};
```

> Using typescript cause we'll be drawing these in the browser.
>
> Using tuples instead of objects as they are easier to parse.


With this in mind let's make the Rules of the dragon curve.

```typescript showLineNumbers=true title="dragon-curve-rules.ts"
// these are the functions that do what we have stated
// in the formal definition of the instruction.

const DragonCurveRules:Rules = {
    I: [false, stay, "F"],
    F: [false, stepForward, "FPH"]
    H: [false, stepForward, "FNH"]
    P: [true, turnLeft]
    N: [true, turnRight]
}
```

## Wait, in which direction do I turn again?

The above example is a simple one, but how about a system where you have to keep track of how far you've moved before you take any further step. For this Let's look at the following set of rules and with the same starting conditions:

- `I` => `F`, stay where you are
- `F` => `H`, move one step in the direction you are facing
- `H` => `HF`, if the number of steps you've taken so far is even, turn left otherwise turn right, and finally move forward

Now, let's do this process 6 times and see the result:

1. `I`
2. `F`
3. `H`
4. `HF`
5. `HFH`
6. `HFHHF`
7. `HFHHFHFH`

This is called the Fibonacci Word Fractal which will look like this if we draw the above final state:

<div image-wrapper><img src={cdnify([false,"/index/pub/fib-6.png"])}/></div>

We have a problem now, we need to track the number of steps we've taken or precisely if the steps taken so far are even or odd.

This can be achieved by using a variable but where do we store it and how do we access it.

Lo and behold, javascript proides us with closures and we can make a function that returns us the ruleset with access to a variable declared inside to use as parity of the steps we've taken, and it'll look like.

```typescript showLineNumbers=true title="fibonacci-word-fractal-rules.ts"
function FibonacciWordFractalRules() {
    let steps_parity = false;
    return {
        I: [false, stay, "F"],
        F: [false, function(pos, dir) {
            steps_parity = !steps_parity;
            return stepForward(pos, dir);
        }, "H"]
        H: [false, function(pos,dir) {
            steps_parity = !steps_parity;
            let new_pos, new_dir;
            if(steps_parity){
                [new_pos, new_dir] = turnRight(pos, dir);
            }else{
                [new_pos, new_dir] = turnLeft(pos, dir);
            }
            return stepForward(new_pos, new_dir)
        }, "HF"]
    } satisfies Rules;
}
```

## The road not taken leads to a playground

Now let's talk about making a playground for generating these fractals by writing the rules directly in the browser and not in the code. To implement the playground we need to design it first. What kind of transformations and operations are we allowed to do:

- **`move`**: move one step in the facing direction.
- **`rotate`**: rotate a given amount of degrees clockwise.
- **`scale`**: remember that our direction is a vector, which is used as step, so we can rescale our step by a given factor.
- **`state_upadate`**: since we are using a function to get the ruleset for uniformity, and can have state, let's define an operation to update a variable in the state.
- **`branch`**: this is like a if statement, what's the use of state if we can't decide our actions based on it.
- **`loop`**: and finally a loop, cause why not.

This is more like defining our own set of operation on a system to simulate some behavior that was previosly hard coded. Boom, we have designed a DSL(Domain Specific Language) for writing the instruction to generating fractals.

If we put on our thinking cap, we can encode it in the typescript's type-syetem. Wanna take a look.

```typescript showLineNumbers=true title="types-for-playground-based-system.ts"
type BinaryOperator =
    | "&&"
    | "||"
    | "^"
    | "==="
    | "!=="
    | ">"
    | ">="
    | "<"
    | "<="
    | "+"
    | "-"
    | "*"
    | "/"
    | "%"
    | "&"
    | "|"
    | "<<"
    | ">>";

type Expression =
    // a raw value
    | ["raw", number | boolean]
    // a variable either from state, of the loop iterator
    // false for state and true for loop iterators along with the name
    | ["var", boolean, string]
    // Not expression
    | ["!", Expression]
    // Binary expression
    | [BinaryOperator, Expression, Expression];

// break and continue
type LoopOps = ["br" | "ct"];

type Transform<InLoop extends boolean = false> =
    // to encode stepForward
    | ["move"]
    // by what angle to rotate right
    | ["rot", number]
    // the factor by which we should scale
    // only positive values allowd
    | ["scale", number]
    // assign the result of expression to state variable with the given name
    // if a variable with the given name does not exist, the parser will error
    | ["asgn", string, Expression]
    // branch based on the condition expression,
    | ["brch", Expression, (InLoop extends true ? Transform<true> | LoopOps : Transform<false>)[]]
    // for when you need an else branch
    | [
          "brch",
          Expression,
          (INLOOP extends true ? Transform<true> | LoopOps : Transform<false>)[],
          (INLOOP extends true ? Transform<true> | LoopOps : Transform<false>)[],
      ]
    // loop while the condition is true
    // provide the name for the iteration variable, initial value,
    // the condition experssion and the update value expression
    // and a the body
    | ["loop", string, Expression, Expression, Expression, (Transform<true> | LoopOps)[]]
    // return statement
    | ["ret"]
    ;

// An instruction can either be terminal or non terminal
// i.e. do we need to expand it or not.
// If it is non terminal where the first value of this tuple is false,
// then the third value of the tuple is what it'll expand into.
type Rule = [false, Transform[], string] | [true, Transform];

type RuleSet = { I: Rule, [key: string]: Rule };

type PlaygroundRules = {
    state: { [key: string]: number | boolean; }
    transforms: RuleSet
};
```

Now let's rewrite our dragon curve and fibonacci word fractal's  rules in the new method;

```typescript showLineNumbers=true title="fractal-rules-in-playground.ts"
function DragonCurveRules() {
    return {
        state: {},
        transforms: {
            I: [false, [], "F"],
            F: [false, [["move"]], "FPH"],
            H: [false, [["move"]], "FNH"],
            P: [true, [["rot", -90]]],
            N: [true, [["rot", 90]]]
        }
    };
}

function FibonacciWordFractalRules() {
    return {
        state: { turns: false }
        transforms: {
            I: [false, [], F],
            F: [
                false,
                [
                    ["asgn", "turns", ["!", ["var", false, "turns"]]],
                    ["move"]
                ],
                "H"
            ],
            "H":[
                false,
                [
                    ["asgn", "turns", ["!", ["var", false, "turns"]]],
                    ["brch", ["var", false, "turns"], [["rot", -90]], [["rot", 90]]],
                    ["move"]
                ],
                "HF"
            ]
        }
    }
}
```

If you take a close look at the allowed operations, this looks more like language where you just write expressions and expression trees explicitly, which finally will get turned into a function that will run in your browser via javascript. Does not sound lovely, I know. But this is what we have for now.

Now I just have one fear, that since I am not allowing declaration of variables, users will exploit the loop as it is the only place to do so, but even then, it's not much useful given the constraints this system has and will just eat away resources.

## Go play in the park

What are you waiting for? I did not made that playground just for myself, go [try it out](/geo-vis) and you'll get some examples there for reference too.

Till then, I'll be floating around.
